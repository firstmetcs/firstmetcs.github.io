<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>iStoreOS使用阿里云ddns+https</title>
    <link href="/2024/01/30/iStoreOS%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91ddns&amp;https/"/>
    <url>/2024/01/30/iStoreOS%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91ddns&amp;https/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本文由 Fluid 用户授权转载，版权归原作者所有。</p><p>本文作者：LSYZZs<br>原文地址：<a href="https://blog.csdn.net/lesiyu116/article/details/127229081">https://blog.csdn.net/lesiyu116/article/details/127229081</a></p>          </div><p><strong>首先声明这篇文章不是保姆级的。假定看这篇帖子的伙伴是有一定基础的。</strong></p><ul><li>在阿里云上购买一个域名 .cn 价位大概在 40 rmb 一年</li><li>然后你要为这个域名备案。国内的没办法。（如果不想这么麻烦可以找其他域名备案商）</li><li>申请一个 AccessKey 子账号<br><img src="http://fsmt-blog.oss-cn-beijing.aliyuncs.com/2024/01/30/17066190233252.jpg"><br><img src="http://fsmt-blog.oss-cn-beijing.aliyuncs.com/2024/01/30/17066190287101.jpg"><br><img src="http://fsmt-blog.oss-cn-beijing.aliyuncs.com/2024/01/30/17066190340413.jpg"><br><img src="http://fsmt-blog.oss-cn-beijing.aliyuncs.com/2024/01/30/17066190405626.jpg"><br><img src="http://fsmt-blog.oss-cn-beijing.aliyuncs.com/2024/01/30/17066190546650.jpg"><br><img src="http://fsmt-blog.oss-cn-beijing.aliyuncs.com/2024/01/30/17066190636303.jpg"><br><img src="http://fsmt-blog.oss-cn-beijing.aliyuncs.com/2024/01/30/17066190693529.jpg"><br>AliyunDNSFullAccess</li></ul><p>点击确定。阿里云上的操作就告一段落了<br>下面是iStoreOS</p><p>在服务中找到 动态DNS 选项卡 点开<br><img src="http://fsmt-blog.oss-cn-beijing.aliyuncs.com/2024/01/30/17066190915554.jpg"><br>点击添加新服务<br><img src="http://fsmt-blog.oss-cn-beijing.aliyuncs.com/2024/01/30/17066191036007.jpg"><br>点击创建服务<br><img src="http://fsmt-blog.oss-cn-beijing.aliyuncs.com/2024/01/30/17066191146820.jpg"><br>到了这个页面 让我们切换到阿里云上。<br>在阿里云的域名解析服务中 新建一条 A 记录 。 记录值随便填<img src="http://fsmt-blog.oss-cn-beijing.aliyuncs.com/2024/01/30/17066191286145.jpg"><br>创建好后回到 iStoreOS<br><img src="http://fsmt-blog.oss-cn-beijing.aliyuncs.com/2024/01/30/17066191413083.jpg"><br>保存并引用。<br>接着设置端口转发 将 80 端口 和 443 端口转发出去。这一步就不多讲了。有需要的可以百度。很多的大神都有讲过。</p><p><strong>在 iStoreOS 的软件商城中下载 uhttpd</strong><br><strong>下面就是配置 https 和证书了。</strong><br>这就不得不说为什么要在阿里云上注册域名了。因为在阿里云上注册域名有免费的ssl证书可以用。每人每年有18个免费证书可以用。<br>生成证书可以安装阿里云的官方教程生成。生成后下载 nginx的证书<br>下载后的证书不能直接用。因为阿里云的 nginx的证书是 pem的<br>而uhttpd 中使用的证书是 crt 的 所以需要转换一下<br><code>openssl x509 -in 证书路径/证书.pem -out 证书导出路径/证书.crt</code><br>将 .key .crt 的证书上传到 iStoreOS 服务器中<br>在 uhttpd 中 将证书地址切换到 上传的证书路径上<br><img src="http://fsmt-blog.oss-cn-beijing.aliyuncs.com/2024/01/30/17066192201679.jpg"><br>设置后点击保存斌应用。</p><p><strong>ok到这里https的证书就设置完成了。剩下的就是在浏览器中输入 https:你的域名:443转发的那个端口号了。</strong><br>例如 443端口转发到 18443 那么就是 https:域名:18443</p>]]></content>
    
    
    <categories>
      
      <category>软路由</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软路由</tag>
      
      <tag>ddns</tag>
      
      <tag>aliddns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>家庭公网 IP 的配置与应用</title>
    <link href="/2024/01/26/%E5%AE%B6%E5%BA%AD%E5%85%AC%E7%BD%91IP%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <url>/2024/01/26/%E5%AE%B6%E5%BA%AD%E5%85%AC%E7%BD%91IP%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本文由 Fluid 用户授权转载，版权归原作者所有。</p><p>本文作者：中天与大瓶子<br>原文地址：<a href="https://sspai.com/post/79532">https://sspai.com/post/79532</a></p>          </div><p>本文主要记录了家庭公网 IP 的申请和配置（以上海电信为例），以及在 NAS 管理、远程观影和游戏机串流等场景的应用。</p><p>家庭公网 IP 的申请与配置</p><h1 id="公网-IP-申请"><a href="#公网-IP-申请" class="headerlink" title="公网 IP 申请"></a>公网 IP 申请</h1><p>公网 IP 的申请比较方便，只需要打电话给客服说你需要公网 IP 就行，客服会直接帮你操作，一般来说 24 小时内就能搞定了。注意有时候客服会问你要公网 IP 做什么，你就回答工作需要或者访问家里的监控之类的原因就行，但是不要说自己在家里面架设网站。</p><h1 id="配置光猫：改为桥接模式"><a href="#配置光猫：改为桥接模式" class="headerlink" title="配置光猫：改为桥接模式"></a>配置光猫：改为桥接模式</h1><p>默认情况下，家里的光猫是「路由模式」，需要改成「桥接模式」。这里让运营商帮锚操作就行，要么客服远程可以修改，要么会帮你联系师傅上门。如果你想要挑战一下自己，也可以去网上搜教程自己动手改。<br>这里简单解释下这一步操作的目的。在「路由模式下」，光猫负责拨号上网，获得的是公网 IP（如果没有申请公网 IP，这里获得的就是运营商内网 IP），而连接到光猫的路由器获得的是 <code>192.168.*.*</code> 这种内网 IP。所以此时其他设备时没办法直接连接到你的路由器的，因为此时路由器并没有暴露到公网上。如果光猫支持端口映射的功能，当然也是可以在路由模式下将路由器暴露到公网的，只是这样比较麻烦。<br><img src="http://fsmt-blog.oss-cn-beijing.aliyuncs.com/2024/01/26/17062493996964.jpg"><br>而在「桥接模式」中，光猫就只负责转换光信号为数字信号，拨号上网的工作就交给了路由器。这样的话，路由器就可以获得公网 IP，公网的设备也就可以直接访问到路由器了。因为路由器是我们自己的设备，可以操作的空间较大，后续的其他操作也都在路由器上开展。<br><img src="http://fsmt-blog.oss-cn-beijing.aliyuncs.com/2024/01/26/17062494113042.jpg"></p><h1 id="配置路由器：拨号上网"><a href="#配置路由器：拨号上网" class="headerlink" title="配置路由器：拨号上网"></a>配置路由器：拨号上网</h1><p>当光猫是「路由模式」，时，路由器对应的网络模式为「DHCP」，即自动获取光猫分配给它的 IP 地址。当光猫改为「桥接模式」后，就需要将路由器的网络模式改为「PPPoE」，即拨号上网模式。路由器切换成该模式后需要手动填入家中宽带的账号密码，这个直接问运营商客服或者上门的运营商师傅就行。</p><p>完成这一步后，可以验证下是否成功获取公网 IP，方法如下：</p><ol><li>在百度搜索「IP」，查看目前访问百度使用的 IP 地址</li><li>进入路由器的后台管理页面，查看 WAN 口获取到的 IP 地址<br><img src="http://fsmt-blog.oss-cn-beijing.aliyuncs.com/2024/01/26/17062494414758.jpg"><br>如果这两个 IP 地址一致，说明路由器已经成功获取到的公网 IP。</li></ol><p>这里列举两种可能的错误情况：</p><ul><li>路由器后台看到的地址是 <code>192.168.*.*</code> 这种 IP：说明光猫没有改成桥接模式，仍然是路由模式</li><li>路由器后台看到的的地址虽然不是 <code>192.168.*.*</code> 这种 IP，但是和百度上看到的也不一致：说明运营商并没有为你开通公网 IP</li></ul><h1 id="配置路由器：开启防火墙"><a href="#配置路由器：开启防火墙" class="headerlink" title="配置路由器：开启防火墙"></a>配置路由器：开启防火墙</h1><p>做完以上两步以后，你的路由器就已经暴露在公网了。这里注意需要把路由器的防火墙打开，不然很容易被黑客攻击。注意以下几个配置要关掉：</p><ul><li>响应来自外网的 ping 请求</li><li>允许从互联网设置路由器</li><li>允许外网访问 SSH 服务器</li></ul><h1 id="配置路由器：端口映射-端口转发"><a href="#配置路由器：端口映射-端口转发" class="headerlink" title="配置路由器：端口映射&#x2F;端口转发"></a>配置路由器：端口映射&#x2F;端口转发</h1><p>目前只是路由器暴露在公网了，但是路由器下面的设备仍然是对公网不可见的。这里就需要进行端口映射，端口映射的作用就是将公网对路由器某个或者某几个特定端口 A 的全部访问转发到内网的某个设备的端口 B 上去。通过端口映射，可以将内网设备的特定端口暴露在公网上，，这样就可以在公网直接访问内网设备了。</p><p>不同品牌的路由器后台设置界面可能不同，以 pandavan 为例：</p><p><img src="http://fsmt-blog.oss-cn-beijing.aliyuncs.com/2024/01/26/17062495102195.jpg"><br>解释下配置的作用：</p><ul><li>源 IP 地址：允许的来源 IP 地址，这里填写 * 代表允许所有来源</li><li>端口范围：上述提到的端口 A</li><li>内网 IP：上述提到的「内网的某个设备」</li><li>本地端口：上述提到的端口 B</li><li>协议：根据实际需求选择，如果不知道需要转发的服务是基于什么协议的，可以直接选「TCP &amp; UDP」</li></ul><h1 id="配置路由器：动态域名服务（可选）"><a href="#配置路由器：动态域名服务（可选）" class="headerlink" title="配置路由器：动态域名服务（可选）"></a>配置路由器：动态域名服务（可选）</h1><p>这个操作需要有一个域名，没有的话可以跳过本节。</p><p>虽然我们获取到了公网 IP，但是这个 IP 不是固定的（固定公网 IP 一般只面向企业，或者要多收钱），每次进行拨号的时候 IP 都会变，也就是说每次路由器重启公网 IP 就变了。为了方便在公网访问，我们可以将固定域名动态映射到路由器获取到的动态公网 IP 上，这样我们只需要访问固定的域名就可以了。</p><h2 id="在云服务商设置域名解析（以腾讯云为例）"><a href="#在云服务商设置域名解析（以腾讯云为例）" class="headerlink" title="在云服务商设置域名解析（以腾讯云为例）"></a>在云服务商设置域名解析（以腾讯云为例）</h2><p>在 DNS 解析页面添加一条记录：</p><ul><li>主机记录：比如我想把 <code>router.my_domain_name.com</code> 这个域名映射到我的路由器，那主机记录这里就填「router」</li><li>记录类型：这里需要填「A」，「A」表示需要将域名指向一个 IP 地址</li><li>记录值：「记录值」表示我想把该域名映射到哪个 IP 地址。因为我们的 IP 地址是动态的，所以这里先随便填，因为这个值需要路由器去主动到腾讯云上修改，这样才能做到动态的 DNS 解析</li></ul><p><img src="http://fsmt-blog.oss-cn-beijing.aliyuncs.com/2024/01/26/17062495616937.jpg"></p><h2 id="路由器配置-DDNS（以-pandavan-为例）"><a href="#路由器配置-DDNS（以-pandavan-为例）" class="headerlink" title="路由器配置 DDNS（以 pandavan 为例）"></a>路由器配置 DDNS（以 pandavan 为例）</h2><p>前面提到了 DDNS 依赖路由器的主动修改，所以就需要给路由器一个腾讯云的 token，路由器可以通过这个 token 将自己当前的 IP 地址上报到腾讯云。腾讯云的管理 token 可以从<a href="https://sspai.com/link?target=https%253A%252F%252Fconsole.cloud.tencent.com%252Fcam%252Fcapi">这里</a>获取。<br><img src="http://fsmt-blog.oss-cn-beijing.aliyuncs.com/2024/01/26/17062495797258.jpg"></p><h1 id="公网-IP-的应用"><a href="#公网-IP-的应用" class="headerlink" title="公网 IP 的应用"></a>公网 IP 的应用</h1><h2 id="NAS-管理：基于-SSH-隧道的公网-RDP-访问"><a href="#NAS-管理：基于-SSH-隧道的公网-RDP-访问" class="headerlink" title="NAS 管理：基于 SSH 隧道的公网 RDP 访问"></a>NAS 管理：基于 SSH 隧道的公网 RDP 访问</h2><p>我家中有一台 NAS，用的是我十年前读大学时买的笔记本电脑。我会在上面放一些电影电视剧，有时候跑一些下载任务。之前我的管理方式是通过 TeamViewer，虽然配置比较方便，使用起来延迟也比较低，但是每次连接比较慢，体验不够完美。而且有些公司是禁止在电脑上安装 TeamViewer 等远程桌面应用的。既然我们已经有了公网 IP，就可以搭建自己的远程桌面服务了。</p><p>最简单的方式是直接将远程桌面的端口通过端口映射暴露到公网上，这样就可以通过 IP 或者域名直连了，就像内网访问那样。但是由于 RDP 协议本身的安全性问题，在公网使用 RDP 存在一定危险性，有中勒索病毒的风险。虽然我的 NAS 上没有什么重要的资料，但是中了勒索病毒就需要清盘重装系统还是比较麻烦的。我们可以搭建 SSH 隧道，然后通过 SSH 隧道运行 RDP，大大提高了安全性。</p><p>SSH 隧道也叫 SSH 端口转发，通过在 SSH 客户端与 SSH 服务端之间建立一个隧道，将网络数据通过该隧道转发至指定端口，从而进行网络通信。关于 SSH 隧道的更多信息可以参考<a href="https://sspai.com/link?target=https%253A%252F%252Fwww.gui2000.com%252Fwww-notes%252Fnotes-58.html">SSH三种隧道方式工作原理详解</a>。</p><p>在我们的场景中，首先建立 SSH 隧道将远程设备 的 RDP 协议端口 A（默认是 3389，这里建议修改成其他高位端口）映射到本地设备的端口 B，这样的话所有对本地端口 B 的访问数据都会转发到远程设备的端口 A。<br>具体步骤如下：</p><ol><li><p>开启远程设备的 SSH 服务器功能<br>网上教程有很多，这里就不赘述了。</p></li><li><p>修改远程设备的 SSH 配置<br>不同系统的 SSH 配置文件路径如下：</p></li></ol><ul><li>Windows：<code>C:\ProgramData\ssh\sshd_config</code></li><li>Linux&#x2F;macOS：<code>~/.ssh/config</code><br>配置文件修改如下：<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">Port</span> <span class="hljs-number">55555</span>  <span class="hljs-comment"># 建议将协议端口从 22 改为其他高位端口，</span><br>PermitRootLogin <span class="hljs-literal">no</span>  <span class="hljs-comment"># 禁止 root 用户登录</span><br>PasswordAuthentication <span class="hljs-literal">no</span>  <span class="hljs-comment"># 禁止使用密码登录</span><br>PubkeyAuthentication <span class="hljs-literal">yes</span>  <span class="hljs-comment"># 使用公钥登录</span><br>AuthorizedKeysFile .ssh/authorized_keys  <span class="hljs-comment"># 已授权公钥保存文件</span><br><span class="hljs-comment"># 对于 Windows 还需要注释下面几行：</span><br><span class="hljs-comment"># Match Group administrators</span><br><span class="hljs-comment"># AuthorizedKeysFile</span><br><span class="hljs-comment">#       PROGRAMDATA/ssh/administrators_authorized_keys</span><br></code></pre></td></tr></table></figure></li></ul><ol start="3"><li><p>在路由器上设置 SSH 端口映射（将远程设备的 SSH 端口映射到公网）<br>参考前面的教程操作即可。也可以直接。</p></li><li><p>建立 SSH 隧道</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh <span class="hljs-variable">$&#123;用户名&#125;</span>@<span class="hljs-variable">$&#123;URL或者路由器公网IP&#125;</span> -p <span class="hljs-variable">$&#123;远程设备映射到外网的端口号&#125;</span> \<br>        -L <span class="hljs-variable">$&#123;前面提到的端口A&#125;</span>:127.0.0.1:<span class="hljs-variable">$&#123;前面提到的端口B&#125;</span> \<br>        -N -f \<br>        -o ServerAliveInterval=60 \<br>        -o ServerAliveCountMax=3<br></code></pre></td></tr></table></figure><p>参考：<a href="https://sspai.com/link?target=https%253A%252F%252Fblog.csdn.net%252Fqwe123321123%252Farticle%252Fdetails%252F116504970">通过SSH隧道安全建立RDP远程桌面连接(RDP over SSH tunnel)</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>软路由</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软路由</tag>
      
      <tag>网络设备</tag>
      
      <tag>公网IP</tag>
      
      <tag>NAS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始搭建家庭软路由系统（安装OpenWrt，并做为旁路由接入家庭网络）</title>
    <link href="/2024/01/26/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E5%AE%B6%E5%BA%AD%E8%BD%AF%E8%B7%AF%E7%94%B1%E7%B3%BB%E7%BB%9F/"/>
    <url>/2024/01/26/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E5%AE%B6%E5%BA%AD%E8%BD%AF%E8%B7%AF%E7%94%B1%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本文由 Fluid 用户授权转载，版权归原作者所有。</p><p>本文作者：–<br>原文地址：<a href="https://whrss.com/post/soft-routes">https://whrss.com/post/soft-routes</a></p>          </div><h1 id="制作启动盘"><a href="#制作启动盘" class="headerlink" title="制作启动盘"></a>制作启动盘</h1><p>我选择的系统是 <a href="https://openwrt.org/">OpenWRT&#x2F;LEDE</a> 在国内的家庭软路由中有着非常高的占有率，拥有海量的软件，和非常强大的生态。同时，OpenWRT 的教程也很丰富详实。<br>这里我使用的是 <a href="https://fw.koolcenter.com/">KoolShare</a> 固件，内置了非常强大的插件市场。</p><h2 id="下载efi"><a href="#下载efi" class="headerlink" title="下载efi"></a>下载efi</h2><p><img src="http://fsmt-blog.oss-cn-beijing.aliyuncs.com/2024/01/26/17062472361442.jpg"><br><img src="http://fsmt-blog.oss-cn-beijing.aliyuncs.com/2024/01/26/17062472598613.jpg"><br>找到最新版本进行下载。<br><img src="http://fsmt-blog.oss-cn-beijing.aliyuncs.com/2024/01/26/17062472701415.jpg"></p><h2 id="写盘"><a href="#写盘" class="headerlink" title="写盘"></a>写盘</h2><p>下载完成后，使用balenaetcher写盘工具进行写盘，</p><ul><li>如果没有安装balenaEtcher，首先需要下载并安装。</li><li>插入你的U盘，并打开balenaEtcher。</li><li>点击“选择镜像”按钮，选择刚才下载的.gz文件。</li><li>点击“选择驱动器”按钮，选择你插入的U盘。</li><li>点击“写入”按钮，balenaEtcher将开始写入镜像文件到你的U盘。</li><li>等待写入过程完成，并在完成后安全地弹出。</li></ul><h1 id="安装和设置"><a href="#安装和设置" class="headerlink" title="安装和设置"></a>安装和设置</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li>将写好的盘插入软路由，接一个显示器和一个键盘给软路由，接上电源，开机。按f11(不同机器不同快捷键)进入快速启动。一切自动执行到终端提示完成，回车，提示出OpenWrt图标。</li><li>输入quickstart，1 设置Lan口IP，2 安装OpenWrt，3 重置 </li><li>选择2安装操作系统。这时候会提示安装位置，如果识别磁盘没有问题，就会让你选择你内部的固态或者sata硬盘。如果提示没有找到硬盘，就是硬盘有问题或者接口接错了（我在使用sata协议的m.2接口固态硬盘时，提示了这个问题，固态硬盘需要选择nvme接口协议的） </li><li>几秒后会提示你拔掉U盘，这时候就会自动重启进入系统。 </li><li>同样的 输入quickstart  选择1 设置lan口IP。可以设置为 192.168.2.6， 子网掩码设置为255.255.255.0（等下会说明用途）</li><li>接一根网线从软路由 lan 口到 PC 上，pc打开浏览器，访问 192.168.2.6 ，这时候会进入软路由后台，用户名root 默认密码 password<br>到这里，安装基本完成，openWrt可以进入后台访问。</li></ul><h2 id="设置旁路由"><a href="#设置旁路由" class="headerlink" title="设置旁路由"></a>设置旁路由</h2><p>旁路由就是将软路由接入在普通硬路由下，做数据处理。<br><img src="http://fsmt-blog.oss-cn-beijing.aliyuncs.com/2024/01/26/17062473422061.jpg"></p><ul><li>在硬路由器控制台上禁用 DHCP 功能，然后记录下其 LAN 口 IP 地址（例如，我的是 192.168.2.5）</li><li>在软路由面板的“网络”下，选择“接口”并设置 LAN 口，将 LAN 口 IP 设置为硬路由器 IP 同一网段（也就是192.168.2.6），将网关地址和 DNS 解析地址都设置为硬路由器 LAN 口地址 192.168.2.5 点击保存并应用。</li></ul><p>拔下PC网线，将软路由Lan口与硬路由Lan口相连。<br>电脑连接原先的硬路由wifi网络， 浏览器输入192.168.2.6，正确访问到软路由后台。再登录软路由后台系统，检查网络状况，已连通。</p>]]></content>
    
    
    <categories>
      
      <category>软路由</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软路由</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis集群的搭建和使用</title>
    <link href="/2024/01/01/redis%E9%9B%86%E7%BE%A4%E7%9A%84%E6%90%AD%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/01/01/redis%E9%9B%86%E7%BE%A4%E7%9A%84%E6%90%AD%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇知识分享主要讲述使用docker搭建redis集群，其中包含redis简单主从模式、哨兵模式和springboot整合redis集群等，适合初学者入门搭建和使用参考。</p><h2 id="基础服务环境"><a href="#基础服务环境" class="headerlink" title="基础服务环境"></a>基础服务环境</h2><p>本篇教程基于docker容器化搭建redis集群，需要使用docker环境。<br>基础环境细节如下：</p><ul><li>Docker环境</li><li>Redis环境（docker latest）</li><li>Java环境</li><li>Maven环境</li></ul><h3 id="搭建docker环境"><a href="#搭建docker环境" class="headerlink" title="搭建docker环境"></a>搭建docker环境</h3><ul><li>卸载旧版本<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum remove docker docker-common docker-selinux<br></code></pre></td></tr></table></figure></li><li>安装需要的依赖包<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install -y yum-utils device-mapper-persistent-data<br></code></pre></td></tr></table></figure></li><li>配置稳定仓库<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo<br></code></pre></td></tr></table></figure></li><li>安装<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install docker-ce<br></code></pre></td></tr></table></figure></li><li>启动docker<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl start docker<br></code></pre></td></tr></table></figure></li><li>验证安装是否成功<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker -v<br></code></pre></td></tr></table></figure></li></ul><h3 id="docker环境配置"><a href="#docker环境配置" class="headerlink" title="docker环境配置"></a>docker环境配置</h3><p>为避免docker容器运行时使用基于docker的局域网环境信息导致后续的springboot使用哨兵模式调用失败，启动时需要添加net网络模式选项：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">–<span class="hljs-attribute">net</span>=host<br></code></pre></td></tr></table></figure><p>这样容器就和宿主机共用网络</p><h1 id="Redis简单主从模式"><a href="#Redis简单主从模式" class="headerlink" title="Redis简单主从模式"></a>Redis简单主从模式</h1><h2 id="搭建基础redis环境"><a href="#搭建基础redis环境" class="headerlink" title="搭建基础redis环境"></a>搭建基础redis环境</h2><h3 id="获取redis镜像"><a href="#获取redis镜像" class="headerlink" title="获取redis镜像"></a>获取redis镜像</h3><p>下面的命令会拉取最新的官方版本的redis镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull redis<br></code></pre></td></tr></table></figure><p>查看镜像<br><img src="http://fsmt-blog.oss-cn-beijing.aliyuncs.com/2024/01/02/17041566160538.jpg"></p><h3 id="获取并修改redis配置文件"><a href="#获取并修改redis配置文件" class="headerlink" title="获取并修改redis配置文件"></a>获取并修改redis配置文件</h3><p>下面的命令会拉取最新的官方版本的redis镜像<br>redis官方提供了一个配置文件样例，通过wget工具下载下来。我用的root用户，就直接下载到用户主目录里了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget http://download.redis.io/redis-stable/redis.conf<br></code></pre></td></tr></table></figure><p><img src="http://fsmt-blog.oss-cn-beijing.aliyuncs.com/2024/01/02/17041567128278.jpg"></p><p>配置文件修改以下几项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs conf"># 注释这一行，表示Redis可以接受任意ip的连接<br># bind 127.0.0.1 <br><br># 关闭保护模式<br>protected-mode no <br><br># 设定密码(可选，如果这里开启了密码要求，slave的配置里就要加这个密码. 只是练习配置，就不使用密码认证了)<br># requirepass masterpassword <br><br># 配置日志路径，为了便于排查问题，指定redis的日志文件目录<br>logfile &quot;/var/log/redis/redis.log&quot;<br></code></pre></td></tr></table></figure><h3 id="使用配置文件启动redis环境"><a href="#使用配置文件启动redis环境" class="headerlink" title="使用配置文件启动redis环境"></a>使用配置文件启动redis环境</h3><p>启动时复制配置文件到容器中并使用配置文件启动redis server</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d -p 6379:6379 --name redis -v /hzero/repo/redis/redis-master.conf:/usr/local/redis.conf redis redis-server /usr/local/redis.conf<br></code></pre></td></tr></table></figure><p>其中&#x2F;hzero&#x2F;repo&#x2F;redis&#x2F;redis-master.conf为下载并修改的配置文件的位置，&#x2F;usr&#x2F;local&#x2F;redis.conf是docker容器中配置文件的位置，redis-server &#x2F;usr&#x2F;local&#x2F;redis.conf表示在容器启动时使用配置文件启动redis server</p><h3 id="注意的坑"><a href="#注意的坑" class="headerlink" title="注意的坑"></a>注意的坑</h3><p>有时候会发现docker使用配置文件启动redis启动失败了，其实并不是启动失败了，而是配置文件中添加了以下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs conf"># 让redis服务后台运行<br>daemonize yes<br></code></pre></td></tr></table></figure><p>daemonize yes，他的作用是是否开启守护进程模式，在该模式下，redis会在后台运行，并将进程pid号写入至redis.conf选项pidfile设置的文件中，此时redis将一直运行，除非手动kill该进程<br>那么通过配置文件的方式启动redis肯定就无法开启守护进程模式，所以导致配置文件中daemonize yes的情况下，无法通过配置文件启动</p><h2 id="搭建主从模式redis集群"><a href="#搭建主从模式redis集群" class="headerlink" title="搭建主从模式redis集群"></a>搭建主从模式redis集群</h2><h3 id="修改主节点master配置"><a href="#修改主节点master配置" class="headerlink" title="修改主节点master配置"></a>修改主节点master配置</h3><p>配置文件修改以下几项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs conf"># 注释这一行，表示Redis可以接受任意ip的连接<br># bind 127.0.0.1 <br><br># 关闭保护模式<br>protected-mode no <br><br># 设定密码(可选，如果这里开启了密码要求，slave的配置里就要加这个密码. 只是练习配置，就不使用密码认证了)<br># requirepass masterpassword <br><br># 配置日志路径，为了便于排查问题，指定redis的日志文件目录<br>logfile &quot;/var/log/redis/redis.log&quot;<br></code></pre></td></tr></table></figure><h3 id="修改从节点slave配置"><a href="#修改从节点slave配置" class="headerlink" title="修改从节点slave配置"></a>修改从节点slave配置</h3><p>配置文件修改以下几项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs conf"># 注释这一行，表示Redis可以接受任意ip的连接<br># bind 127.0.0.1 <br><br># 关闭保护模式<br>protected-mode no <br><br># 设定密码(可选，如果这里开启了密码要求，slave的配置里就要加这个密码)<br>requirepass masterpassword <br><br># 设定主库的密码，用于认证，如果主库开启了requirepass选项这里就必须填相应的密码<br>masterauth &lt;master-password&gt;<br><br># 设定master的IP和端口号，redis配置文件中的默认端口号是6379<br># 低版本的redis这里会是slaveof，意思是一样的，因为slave是比较敏感的词汇，所以在redis后面的版本中不在使用slave的概念，取而代之的是replica<br># 将35.236.172.131做为主，其余两台机器做从。ip和端口号按照机器和配置做相应修改。<br>replicaof 35.236.172.131 6379<br><br># 配置日志路径，为了便于排查问题，指定redis的日志文件目录<br>logfile &quot;/var/log/redis/redis.log&quot;<br></code></pre></td></tr></table></figure><h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>分别在主机和从机上按照上面的方法建立好配置文件，检查无误后就可以开始启动容器了。<br>我们在三台机器上分别将容器别名指定为redis, redis-slave，这样便于区分与说明，docker通过–name参数来指定容器的别名。redis是master上容器的别名，redis-slave是slave上的别名。<br>只是要注意master的配置文件和slave不同。不过首先要启动主服务器，也就是redis容器。然后再启动redis-slave。<br>在此处为了区分主从两个容器，分别给主服务器6379端口和从服务器6380端口<br>启动主服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d -p 6379:6379 --name redis -v /hzero/repo/redis/redis-master.conf:/usr/local/redis.conf redis redis-server /usr/local/redis.conf<br></code></pre></td></tr></table></figure><p>然后启动从服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d -p 6380:6379 --name redis-slave -v /hzero/repo/redis/redis-slave.conf:/usr/local/redis.conf redis redis-server /usr/local/redis.conf<br></code></pre></td></tr></table></figure><p><img src="http://fsmt-blog.oss-cn-beijing.aliyuncs.com/2024/01/02/17041567622316.jpg"></p><h3 id="测试（验证主从复制）"><a href="#测试（验证主从复制）" class="headerlink" title="测试（验证主从复制）"></a>测试（验证主从复制）</h3><p>使用以下命令进入redis的容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it redis bash<br></code></pre></td></tr></table></figure><p>使用redis-cli进入容器，查看现有的key，可以看到为空<br><img src="http://fsmt-blog.oss-cn-beijing.aliyuncs.com/2024/01/01/17041135641014.jpg"></p><p>在此服务器环境设置一个新key并查看：<br><img src="http://fsmt-blog.oss-cn-beijing.aliyuncs.com/2024/01/01/17041135822950.jpg"></p><p>此时只在主服务器上设置了key，在从服务器应该自动复制过去一份，我们使用以下命令进入从服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it redis-slave bash<br></code></pre></td></tr></table></figure><p><img src="http://fsmt-blog.oss-cn-beijing.aliyuncs.com/2024/01/01/17041136048755.jpg"><br>可以看到从服务器已经复制了主服务器上的key<br>至此，主从集群模式的redis已经搭建成功。</p><h1 id="Redis哨兵模式的集群"><a href="#Redis哨兵模式的集群" class="headerlink" title="Redis哨兵模式的集群"></a>Redis哨兵模式的集群</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>之前介绍了用docker来搭建redis主从环境，但这只是对数据添加了从库备份(主从复制)，当主库down掉的时候，从库是不会自动升级为主库的，也就是说，该redis主从集群并非是高可用的。<br>但是如果主发生故障，需要人工手动切换从机为主机。这种切换工作不仅浪费人力资源，更大的影响是主从切换期间这段时间redis是无法对外提供服务的。因此，哨兵系统被开发出来了，哨兵可以在主发生故障后，自动进行故障转移，从从机里选出一台升级为主机，并持续监听着原来的主机，当原来的主机恢复后，会将其作为新主的从机。</p><h3 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h3><p>目前来说，高可用(主从复制、主从切换)redis集群有两种方案，一种是redis-sentinel，只有一个master，各实例数据保持一致；一种是redis-cluster，也叫分布式redis集群，可以有多个master，数据分片分布在这些master上。<br>  本文介绍基于docker和redis-sentinel的高可用redis集群搭建，大多数情况下，redis-sentinel也需要做高可用，这里先对redis搭建一主二从环境，另外需要3个redis-sentinel监控redis master。<br>很显然，只使用单个redis-sentinel进程来监控redis集群是不可靠的，由于redis-sentinel本身也有single-point-of-failure-problem(单点问题)，当出现问题时整个redis集群系统将无法按照预期的方式切换主从。官方推荐：一个健康的集群部署，至少需要3个Sentinel实例。另外，redis-sentinel只需要配置监控redis master，而集群之间可以通过master相互通信。<br>实际可靠的redis集群拓扑图如下：<br><img src="http://fsmt-blog.oss-cn-beijing.aliyuncs.com/2024/01/02/17041568039151.jpg"></p><h3 id="redis-sentinel"><a href="#redis-sentinel" class="headerlink" title="redis-sentinel"></a>redis-sentinel</h3><p>redis-sentinel作为独立的服务，用于管理多个redis实例，该系统主要执行以下三个任务：</p><ul><li>监控 (Monitor): 检查redis主、从实例是否正常运作</li><li>通知 (Notification): 监控的redis服务出现问题时，可通过API发送通知告警</li><li>自动故障迁移 (Automatic Failover): 当检测到redis主库不能正常工作时，redis-sentinel会开始做自动故障判断、迁移等操作，先是移除失效redis主服务，然后将其中一个从服务器升级为新的主服务器，并让失效主服务器的其他从服务器改为复制新的主服务器。当客户端试图连接失效的主服务器时，集群也会向客户端返回最新主服务器的地址，使得集群可以使用新的主服务器来代替失效服务器</li></ul><h2 id="添加哨兵模式"><a href="#添加哨兵模式" class="headerlink" title="添加哨兵模式"></a>添加哨兵模式</h2><h3 id="搭建三节点redis主从集群"><a href="#搭建三节点redis主从集群" class="headerlink" title="搭建三节点redis主从集群"></a>搭建三节点redis主从集群</h3><p>在上面的基础上新建一个从服务器，分别将两个从服务器的name设置为redis-slave-1和redis-slave-2，其中redis-slave-2端口设置为6381，并且此时为了方便外围系统通过sentinel调用redis集群并且方便sentinel通过端口区分redis集群的机器，需要更改启动命令为如下：<br>启动主服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d --net host --name redis -v /hzero/repo/redis/redis-master.conf:/usr/local/redis.conf redis redis-server /usr/local/redis.conf<br></code></pre></td></tr></table></figure><p>启动从服务器1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d --net host --name redis-slave-1 -v /hzero/repo/redis/redis-slave-1.conf:/usr/local/redis.conf redis redis-server /usr/local/redis.conf<br></code></pre></td></tr></table></figure><p>启动从服务器2</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d --net host --name redis-slave-2 -v /hzero/repo/redis/redis-slave-2.conf:/usr/local/redis.conf redis redis-server /usr/local/redis.conf<br></code></pre></td></tr></table></figure><p><img src="http://fsmt-blog.oss-cn-beijing.aliyuncs.com/2024/01/02/17041568499158.jpg"></p><p>进入主服务器可以看到：<br>主服务器正确识别到两个slave：<br><img src="http://fsmt-blog.oss-cn-beijing.aliyuncs.com/2024/01/01/17041137001865.jpg"></p><p>两个slave也正确的挂载到了master上：<br><img src="http://fsmt-blog.oss-cn-beijing.aliyuncs.com/2024/01/01/17041137220816.jpg"></p><h3 id="获取并修改sentinel配置"><a href="#获取并修改sentinel配置" class="headerlink" title="获取并修改sentinel配置"></a>获取并修改sentinel配置</h3><p>通过wget命令获取sentinel的配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget http://download.redis.io/redis-stable/sentinel.conf<br></code></pre></td></tr></table></figure><p><img src="http://fsmt-blog.oss-cn-beijing.aliyuncs.com/2024/01/02/17041568851681.jpg"></p><p>修改配置文件以下几项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs conf"><br># 修改日志文件的路径<br>logfile &quot;/var/log/redis/sentinel.log&quot;<br><br># 修改监控的主redis服务器<br># 最后一个2表示，两台机器判定主被动下线后，就进行failover(故障转移)<br>sentinel monitor mymaster 35.236.172.131 6379 2<br></code></pre></td></tr></table></figure><h3 id="启动容器并查看日志状态"><a href="#启动容器并查看日志状态" class="headerlink" title="启动容器并查看日志状态"></a>启动容器并查看日志状态</h3><p>通过以下命令启动容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it --name sentinel --net host -v /hzero/repo/redis/sentinel.conf:/usr/local/etc/redis/sentinel.conf -d redis redis-sentinel /usr/local/etc/redis/sentinel.conf<br></code></pre></td></tr></table></figure><p>其中&#x2F;hzero&#x2F;repo&#x2F;redis&#x2F;sentinel.conf为下载并修改的配置文件的位置，&#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;sentinel.conf是docker容器中配置文件的位置，redis-sentinel &#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;sentinel.conf表示在容器启动时使用配置文件启动哨兵<br><img src="http://fsmt-blog.oss-cn-beijing.aliyuncs.com/2024/01/02/17041569201068.jpg"></p><p>通过日志可以查看到，两个slave通过设置的master的监控正确的被sentinel识别到。</p><h3 id="测试sentinel"><a href="#测试sentinel" class="headerlink" title="测试sentinel"></a>测试sentinel</h3><p>重新开一个shell并且停掉master：<br><img src="http://fsmt-blog.oss-cn-beijing.aliyuncs.com/2024/01/02/17041569592079.jpg"></p><p>通过sentinel的日志可以看到哨兵判断6379端口的master下线，并且开始投票选举新的master，选举完毕后将主服务器切换到了新的master上，然后将其他的还在线的从服务器挂载到新的master上面去。</p><p>此时登陆新的master查看集群信息：<br><img src="http://fsmt-blog.oss-cn-beijing.aliyuncs.com/2024/01/01/17041137983846.jpg"></p><p>可以看到原本的slave-2角色已经由slave转换为master，原本的slave-1也已经挂载到了新的master上：<br><img src="http://fsmt-blog.oss-cn-beijing.aliyuncs.com/2024/01/01/17041138164977.jpg"></p><p>此时重启原来的master，它并不会重新作为master运行，在哨兵的控制下他会以slave的角色挂载到新的master上。<br>查看sentinel日志可以看到：<br><img src="http://fsmt-blog.oss-cn-beijing.aliyuncs.com/2024/01/02/17041570142774.jpg"></p><p>再进入新的主服务器可以查看原来的master已经作为slave角色挂载：<br><img src="http://fsmt-blog.oss-cn-beijing.aliyuncs.com/2024/01/01/17041138554218.jpg"></p><p>进入原来的主服务器也可以查看角色已经切换为了slave<br><img src="http://fsmt-blog.oss-cn-beijing.aliyuncs.com/2024/01/01/17041138708495.jpg"></p><p>至此，哨兵模式下的redis集群已经搭建完毕！</p><h1 id="springboot整合redis哨兵模式"><a href="#springboot整合redis哨兵模式" class="headerlink" title="springboot整合redis哨兵模式"></a>springboot整合redis哨兵模式</h1><h2 id="普通springboot项目整合哨兵"><a href="#普通springboot项目整合哨兵" class="headerlink" title="普通springboot项目整合哨兵"></a>普通springboot项目整合哨兵</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>pom.xml 添加Redis依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- redis --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>application.yml 添加Redis配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">redis:</span><br>  <span class="hljs-comment">##哨兵</span><br>  <span class="hljs-attr">sentinel:</span><br>    <span class="hljs-attr">master:</span> <span class="hljs-string">mymaster</span><br>    <span class="hljs-attr">nodes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-number">172.21</span><span class="hljs-number">.0</span><span class="hljs-number">.211</span><span class="hljs-string">:7005</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-number">172.21</span><span class="hljs-number">.0</span><span class="hljs-number">.211</span><span class="hljs-string">:7006</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-number">172.21</span><span class="hljs-number">.0</span><span class="hljs-number">.211</span><span class="hljs-string">:7007</span><br>  <span class="hljs-comment">##</span><br>  <span class="hljs-attr">jedis:</span><br>    <span class="hljs-attr">pool:</span><br>      <span class="hljs-comment">### 连接池最大连接数（使用负值表示没有限制） </span><br>      <span class="hljs-attr">max-active:</span> <span class="hljs-number">9</span><br>      <span class="hljs-comment">### 连接池最大阻塞等待时间（使用负值表示没有限制）</span><br>      <span class="hljs-attr">max-wait:</span> <span class="hljs-number">-1</span><br>      <span class="hljs-comment">### 连接池中的最大空闲连接 </span><br>      <span class="hljs-attr">max-idle:</span> <span class="hljs-number">9</span><br>      <span class="hljs-comment">### 连接池中的最小空闲连接 </span><br>      <span class="hljs-attr">min-idle:</span> <span class="hljs-number">0</span><br>  <span class="hljs-comment">### Redis数据库索引(默认为0) </span><br>  <span class="hljs-attr">database:</span> <span class="hljs-number">0</span><br>  <span class="hljs-comment">### 连接超时时间（毫秒） </span><br>  <span class="hljs-attr">timeout:</span> <span class="hljs-number">60000</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Redis</tag>
      
      <tag>Redis sentinel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【置顶】站点公告</title>
    <link href="/2024/01/01/%E7%AB%99%E7%82%B9%E5%85%AC%E5%91%8A/"/>
    <url>/2024/01/01/%E7%AB%99%E7%82%B9%E5%85%AC%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><blockquote><p>We can’t all be a Leander rising from the ocean to embrace the object of our adoration, and I suppose in your case it’s rather more likely to be the other way around.<br>—— Sherlock Holmes</p></blockquote><p>朋友，你好。</p><p>欢迎来到我的博客，这里日常分享一些技术文章、知识总结和建站经验，偶尔记录一点个人生活碎片。</p><p>你可以在 <a href="/about/">关于</a> 页面找到我的联系方式。</p><p>祝你玩得开心！</p><h1 id="网站公告"><a href="#网站公告" class="headerlink" title="网站公告"></a>网站公告</h1><h2 id="2024-01-01"><a href="#2024-01-01" class="headerlink" title="2024-01-01"></a>2024-01-01</h2><div class="note note-info">            <p>🎉站点公告正式上线</p>          </div>]]></content>
    
    
    <categories>
      
      <category>站点公告</category>
      
    </categories>
    
    
    <tags>
      
      <tag>站点公告</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
